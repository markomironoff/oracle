https://blogs.oracle.com/optimizer/post/how-to-generate-a-useful-sql-execution-plan
https://blogs.oracle.com/optimizer/post/how-do-i-display-and-read-the-execution-plans-for-a-sql-statement
https://www.bobbydurrettdba.com/2020/01/28/query-plan-change-diagnosis-example/?utm_source=chatgpt.com

You can build a controlled scenario in a lab environment to study query plan changes and execution plan troubleshooting. 
In fact, it‚Äôs one of the best ways to internalize these concepts. Here‚Äôs a structured way to do it:
1Ô∏è‚É£ Set up a representative schema

Create tables that mimic the structure of your production tables (e.g., AMS_CASE_S, DM_SYSOBJECT_S) including the primary keys and repeating
attributes if relevant.

Populate them with realistic but smaller test data‚Äîenough rows to make execution plans meaningful but not so large that your lab server chokes.

CREATE TABLE ams_case_s (
    r_object_id VARCHAR2(16) PRIMARY KEY,
    ams_responsibleorganisation VARCHAR2(2000),
    ams_notes VARCHAR2(2000),
    ...
);

CREATE TABLE dm_sysobject_s (
    r_object_id VARCHAR2(16) PRIMARY KEY,
    i_has_folder NUMBER(1),
    i_is_deleted NUMBER(1),
    ...
);


Insert sample data with some repetitive patterns to simulate joins and filters.
2Ô∏è‚É£ Create indexes selectively

Add indexes like you were experimenting in production:

CREATE INDEX idx_case_filter
ON ams_case_s (ams_responsibleorganisation);

CREATE INDEX idx_sysobject_filter
ON dm_sysobject_s (i_has_folder, i_is_deleted);


Compare performance with and without these indexes using EXPLAIN PLAN or DBMS_XPLAN.DISPLAY_CURSOR.
3Ô∏è‚É£ Control statistics

You can deliberately change table statistics to observe how the optimizer reacts:

EXEC DBMS_STATS.GATHER_TABLE_STATS('SCHEMA_NAME','AMS_CASE_S', cascade=>TRUE);


Then modify statistics (e.g., artificially lower NUM_DISTINCT or NUM_ROWS) to see plan changes.
4Ô∏è‚É£ Introduce subtle changes

Add new indexes, drop old ones, or tweak data distribution.

Change optimizer parameters temporarily to simulate different execution plan choices:

ALTER SESSION SET optimizer_mode = FIRST_ROWS;
ALTER SESSION SET optimizer_index_cost_adj = 50;


Run queries and capture execution plans to observe differences.
5Ô∏è‚É£ Track plan changes

Use DBMS_XPLAN.DISPLAY_CURSOR or DBA_HIST_SQLSTAT to capture plan history.

Store snapshots of execution plans for comparison after each change.
6Ô∏è‚É£ Experiment with plan forcing

Learn SQL Profiles or SQL Plan Baselines:

-- Capture current plan
EXEC DBMS_SPM.CREATE_SQL_PLAN_BASELINE(
    sql_handle => 'your_sql_handle',
    plan_name => 'baseline_plan'
);

-- Force usage
EXEC DBMS_SPM.ALTER_SQL_PLAN_BASELINE(
    sql_handle => 'your_sql_handle',
    plan_name => 'baseline_plan',
    attribute_name => 'ENABLED',
    attribute_value => 'YES'
);


This helps you test controlling optimizer behavior without touching production.
üí° Benefits

Safe experimentation without impacting production.

See exactly how indexes, stats, and optimizer settings influence plan selection.

Build intuition on why nested loops vs hash joins happen, why repeating tables are accessed the way they are, etc.

Let‚Äôs set up a lab scenario that mirrors your Documentum tables and queries, so you can experiment with execution plans, indexes, and optimizer behavior safely. I‚Äôll keep it fully self-contained for a local Oracle instance.

1Ô∏è‚É£ Create tables
-- Simulate AMS_CASE_S
CREATE TABLE ams_case_s (
    r_object_id VARCHAR2(16) PRIMARY KEY,
    ams_responsibleorganisation VARCHAR2(200),
    ams_notes VARCHAR2(200),
    i_partition NUMBER(10)
);

-- Simulate DM_SYSOBJECT_S (supertype repeating attributes)
CREATE TABLE dm_sysobject_s (
    r_object_id VARCHAR2(16) PRIMARY KEY,
    i_has_folder NUMBER(1),
    i_is_deleted NUMBER(1)
);

-- Optional: another table to join, like AMS_FOLDER_S
CREATE TABLE ams_folder_s (
    r_object_id VARCHAR2(16) PRIMARY KEY,
    ams_responsibleorganisation VARCHAR2(200)
);

2Ô∏è‚É£ Populate tables with sample data
-- AMS_CASE_S
BEGIN
    FOR i IN 1..100000 LOOP
        INSERT INTO ams_case_s VALUES (
            'CASE_' || i,
            'Org_' || MOD(i, 50),
            'Note_' || MOD(i, 20),
            MOD(i, 10)
        );
    END LOOP;
    COMMIT;
END;
/

-- DM_SYSOBJECT_S
BEGIN
    FOR i IN 1..100000 LOOP
        INSERT INTO dm_sysobject_s VALUES (
            'CASE_' || i,
            MOD(i,2),  -- i_has_folder 0/1
            MOD(i,5)   -- i_is_deleted 0..4
        );
    END LOOP;
    COMMIT;
END;
/

-- AMS_FOLDER_S
BEGIN
    FOR i IN 1..50000 LOOP
        INSERT INTO ams_folder_s VALUES (
            'FOLDER_' || i,
            'Org_' || MOD(i,50)
        );
    END LOOP;
    COMMIT;
END;
/


‚ö†Ô∏è You can scale row counts up/down depending on your lab machine resources.

2Ô∏è‚É£ Populate tables with sample data
-- AMS_CASE_S
BEGIN
    FOR i IN 1..100000 LOOP
        INSERT INTO ams_case_s VALUES (
            'CASE_' || i,
            'Org_' || MOD(i, 50),
            'Note_' || MOD(i, 20),
            MOD(i, 10)
        );
    END LOOP;
    COMMIT;
END;
/

-- DM_SYSOBJECT_S
BEGIN
    FOR i IN 1..100000 LOOP
        INSERT INTO dm_sysobject_s VALUES (
            'CASE_' || i,
            MOD(i,2),  -- i_has_folder 0/1
            MOD(i,5)   -- i_is_deleted 0..4
        );
    END LOOP;
    COMMIT;
END;
/

-- AMS_FOLDER_S
BEGIN
    FOR i IN 1..50000 LOOP
        INSERT INTO ams_folder_s VALUES (
            'FOLDER_' || i,
            'Org_' || MOD(i,50)
        );
    END LOOP;
    COMMIT;
END;
/


‚ö†Ô∏è You can scale row counts up/down depending on your lab machine resources.
4Ô∏è‚É£ Gather statistics
EXEC DBMS_STATS.GATHER_TABLE_STATS('YOUR_SCHEMA','AMS_CASE_S', cascade=>TRUE);
EXEC DBMS_STATS.GATHER_TABLE_STATS('YOUR_SCHEMA','DM_SYSOBJECT_S', cascade=>TRUE);
EXEC DBMS_STATS.GATHER_TABLE_STATS('YOUR_SCHEMA','AMS_FOLDER_S', cascade=>TRUE);

5Ô∏è‚É£ Example query to test plan behavior
SELECT c.r_object_id,
       c.ams_responsibleorganisation,
       f.ams_responsibleorganisation AS folder_org,
       d.i_has_folder,
       d.i_is_deleted
FROM ams_case_s c
JOIN dm_sysobject_s d ON c.r_object_id = d.r_object_id
JOIN ams_folder_s f ON c.ams_responsibleorganisation = f.ams_responsibleorganisation
WHERE d.i_has_folder = 1
  AND d.i_is_deleted = 0
  AND c.ams_responsibleorganisation = 'Org_10';
-- 0,118 seconds

6Ô∏è‚É£ Check execution plan
EXPLAIN PLAN FOR
SELECT c.r_object_id,
       c.ams_responsibleorganisation,
       f.ams_responsibleorganisation AS folder_org,
       d.i_has_folder,
       d.i_is_deleted
FROM ams_case_s c
JOIN dm_sysobject_s d ON c.r_object_id = d.r_object_id
JOIN ams_folder_s f ON c.ams_responsibleorganisation = f.ams_responsibleorganisation
WHERE d.i_has_folder = 1
  AND d.i_is_deleted = 0
  AND c.ams_responsibleorganisation = 'Org_10';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

7Ô∏è‚É£ Things you can experiment with

Add/drop indexes on different columns and see how the plan changes.

Manipulate statistics (e.g., DBMS_STATS.SET_TABLE_STATS) to simulate growth or skewed data.

Force optimizer parameters in session:

ALTER SESSION SET optimizer_index_cost_adj = 50;
ALTER SESSION SET optimizer_index_caching = 75;
ALTER SESSION SET optimizer_mode = ALL_ROWS;


Introduce more joins or simulate repeating attributes to see nested loops vs hash joins.

Capture plan history with DBMS_XPLAN.DISPLAY_CURSOR to compare changes after modifications.

-- ==================================================
-- Documentum-like Lab Environment Script
-- Single file: tables, views, indexes, stats, query
-- ==================================================

-- =============================================
-- 1Ô∏è‚É£ Create supertype tables (_s and _r)
-- =============================================
CREATE TABLE dm_sysobject_s (
    r_object_id VARCHAR2(16) PRIMARY KEY,
    i_has_folder NUMBER(1),
    i_is_deleted NUMBER(1)
);

CREATE TABLE dm_sysobject_r (
    r_object_id VARCHAR2(16),
    r_position NUMBER,
    attribute_value VARCHAR2(200),
    CONSTRAINT dm_sysobject_r_pk PRIMARY KEY (r_object_id, r_position)
);

-- =============================================
-- 2Ô∏è‚É£ Create subtype tables (_s and _r)
-- =============================================
CREATE TABLE ams_case_s (
    r_object_id VARCHAR2(16) PRIMARY KEY,
    ams_responsibleorganisation VARCHAR2(200),
    ams_notes VARCHAR2(200)
);

CREATE TABLE ams_case_r (
    r_object_id VARCHAR2(16),
    r_position NUMBER,
    ams_personalname VARCHAR2(200),
    CONSTRAINT ams_case_r_pk PRIMARY KEY (r_object_id, r_position)
);

CREATE TABLE ams_folder_s (
    r_object_id VARCHAR2(16) PRIMARY KEY,
    ams_responsibleorganisation VARCHAR2(200)
);

-- =============================================
-- 3Ô∏è‚É£ Create views (_sp and _rp)
-- =============================================
CREATE VIEW ams_case_sp AS
SELECT c.r_object_id,
       c.ams_responsibleorganisation,
       c.ams_notes,
       d.i_has_folder,
       d.i_is_deleted
FROM ams_case_s c
JOIN dm_sysobject_s d ON c.r_object_id = d.r_object_id;

CREATE VIEW ams_case_rp AS
SELECT r.r_object_id,
       r.r_position,
       r.ams_personalname
FROM ams_case_r r;

-- =============================================
-- 4Ô∏è‚É£ Populate tables
-- =============================================
DECLARE
    i NUMBER;
BEGIN
    -- dm_sysobject_s
    FOR i IN 1..100000 LOOP
        INSERT INTO dm_sysobject_s VALUES ('CASE_'||i, MOD(i,2), MOD(i,3));
    END LOOP;

    -- ams_case_s
    FOR i IN 1..100000 LOOP
        INSERT INTO ams_case_s VALUES ('CASE_'||i, 'Org_'||MOD(i,50), 'Note_'||MOD(i,20));
    END LOOP;

    -- ams_case_r (repeating attributes)
    FOR i IN 1..100000 LOOP
        INSERT INTO ams_case_r VALUES ('CASE_'||i, 1, 'Person_'||MOD(i,10));
        INSERT INTO ams_case_r VALUES ('CASE_'||i, 2, 'Person_'||MOD(i,20));
    END LOOP;

    -- ams_folder_s
    FOR i IN 1..50000 LOOP
        INSERT INTO ams_folder_s VALUES ('FOLDER_'||i, 'Org_'||MOD(i,50));
    END LOOP;

    COMMIT;
END;
/

-- =============================================
-- 5Ô∏è‚É£ Create indexes similar to production
-- =============================================
CREATE INDEX idx_case_responsible ON ams_case_s(ams_responsibleorganisation);
CREATE INDEX idx_case_s_notes ON ams_case_s(ams_notes);
CREATE INDEX idx_sysobject_flags ON dm_sysobject_s(i_has_folder, i_is_deleted);
CREATE INDEX idx_case_r_person ON ams_case_r(ams_personalname);
CREATE INDEX idx_folder_responsible ON ams_folder_s(ams_responsibleorganisation);

-- =============================================
-- 6Ô∏è‚É£ Gather statistics
-- =============================================
BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(USER, 'AMS_CASE_S', cascade=>TRUE);
    DBMS_STATS.GATHER_TABLE_STATS(USER, 'AMS_CASE_R', cascade=>TRUE);
    DBMS_STATS.GATHER_TABLE_STATS(USER, 'DM_SYSOBJECT_S', cascade=>TRUE);
    DBMS_STATS.GATHER_TABLE_STATS(USER, 'AMS_FOLDER_S', cascade=>TRUE);
END;
/

-- =============================================
-- 7Ô∏è‚É£ Test query (similar to production)
-- =============================================
EXPLAIN PLAN FOR
SELECT c.r_object_id,
       c.ams_responsibleorganisation,
       c.ams_notes,
       d.i_has_folder,
       d.i_is_deleted,
       r.ams_personalname
FROM ams_case_sp c
JOIN dm_sysobject_s d ON c.r_object_id = d.r_object_id
JOIN ams_case_rp r ON c.r_object_id = r.r_object_id
WHERE d.i_has_folder = 1
  AND d.i_is_deleted = 0
  AND c.ams_responsibleorganisation = 'Org_10';

-- Display execution plan
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);


SQL> r
  1* SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY)

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Plan hash value: 1868451607

---------------------------------------------------------------------------------------
| Id  | Operation            | Name           | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |                |  3998 |   292K|   480   (1)| 00:00:01 |
|*  1 |  HASH JOIN           |                |  3998 |   292K|   480   (1)| 00:00:01 |
|   2 |   NESTED LOOPS       |                |  2000 |   105K|   240   (1)| 00:00:01 |
|*  3 |    HASH JOIN         |                |  2000 | 86000 |   240   (1)| 00:00:01 |
|*  4 |     TABLE ACCESS FULL| AMS_CASE_S     |  2000 | 52000 |   137   (1)| 00:00:01 |
|*  5 |     TABLE ACCESS FULL| DM_SYSOBJECT_S | 16667 |   276K|   103   (1)| 00:00:01 |

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
|*  6 |    INDEX UNIQUE SCAN | SYS_C008599    |     1 |    11 |     0   (0)| 00:00:01 |
|   7 |   TABLE ACCESS FULL  | AMS_CASE_R     |   200K|  4101K|   239   (1)| 00:00:01 |
---------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("C"."R_OBJECT_ID"="R"."R_OBJECT_ID")
   3 - access("C"."R_OBJECT_ID"="D"."R_OBJECT_ID")
   4 - filter("C"."AMS_RESPONSIBLEORGANISATION"='Org_10')
   5 - filter("D"."I_IS_DELETED"=0 AND "D"."I_HAS_FOLDER"=1)

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   6 - access("C"."R_OBJECT_ID"="D"."R_OBJECT_ID")

23 rows selected.

üîç 1. The Big Picture

The top line (Id 0 | SELECT STATEMENT) shows the overall query, and each indented line below represents an operation in the execution tree.
The Id numbers indicate the order of execution (Oracle typically executes bottom-up).

üß© 2. The Execution Tree Breakdown
Id	Operation	Description
0	SELECT STATEMENT	The main query node (final result).
1	HASH JOIN	Joins two result sets using a hash table. This is the main join between two large result sets.
2	NESTED LOOPS	One input drives repeated lookups into another (useful when one side is small).
3	HASH JOIN	Another join inside the nested loop; joins two tables.
4	TABLE ACCESS FULL on AMS_CASE_S	Full table scan; all rows are read. Filter applied.
5	TABLE ACCESS FULL on DM_SYSOBJECT_S	Full table scan; all rows are read. Filter applied.
6	INDEX UNIQUE SCAN on SYS_C008599	Uses a unique index (likely a PK or unique constraint) for fast lookup.
7	TABLE ACCESS FULL on AMS_CASE_R	Another full table scan (large table ‚Äî 200K rows).
üìö 3. Understanding the ‚ÄúPredicate Information‚Äù

This section tells you which conditions were applied at each step:

Id	Predicate	Meaning
1	"C"."R_OBJECT_ID"="R"."R_OBJECT_ID"	Join between AMS_CASE_S (C) and AMS_CASE_R (R)
3	"C"."R_OBJECT_ID"="D"."R_OBJECT_ID"	Join between AMS_CASE_S (C) and DM_SYSOBJECT_S (D)
4	"C"."AMS_RESPONSIBLEORGANISATION"='Org_10'	Filter on the AMS_CASE_S table
5	"D"."I_IS_DELETED"=0 AND "D"."I_HAS_FOLDER"=1	Filter on DM_SYSOBJECT_S
6	"C"."R_OBJECT_ID"="D"."R_OBJECT_ID"	Index scan lookup condition
‚öôÔ∏è 4. Step-by-Step Execution Flow (Bottom-Up)

Let‚Äôs walk through the actual execution:

Id 4: Full table scan on AMS_CASE_S

Reads all rows where AMS_RESPONSIBLEORGANISATION = 'Org_10'.

Id 5: Full table scan on DM_SYSOBJECT_S

Reads all rows where I_IS_DELETED = 0 and I_HAS_FOLDER = 1.

Id 3: Hash join between those two tables (C and D).

Joins on R_OBJECT_ID.

Produces about 2000 rows (after filtering and joining).

Id 6: For each resulting row, an INDEX UNIQUE SCAN on SYS_C008599 happens ‚Äî likely to validate or fetch related data.

Id 7: A full scan on AMS_CASE_R (a large table with 200K rows).

Id 2: The NESTED LOOPS operation pairs the result of step 3 with matching rows from step 6 or 7 (depending on the join order).

Id 1: Finally, a HASH JOIN combines everything (the result from the nested loops and AMS_CASE_R) into the final output of ~4,000 rows.

üìà 5. Performance Clues
Metric	Observation
Cost (480)	Not huge, but there are multiple full table scans ‚Äî could be tuned.
Rows estimate (‚âà4000)	The optimizer expects a moderate result size.
Hash joins + nested loops	Suggest mixed join strategies due to varying table sizes.
Full table scans	Possibly due to lack of selective indexes on join/filter columns.
ü©∫ 6. Simplified Interpretation

You can think of it like this:

AMS_CASE_S (filtered by Org_10)
   ‚®ù (hash join on R_OBJECT_ID)
DM_SYSOBJECT_S (filtered by flags)
   ‚Ü≥ result joined (nested loop + hash join)
AMS_CASE_R (large table, joined on R_OBJECT_ID)


The plan builds up partial results from smaller filtered sets, joins them via hash joins, and then loops into a larger table to finalize results.

‚úÖ 7. What You Can Do as a DBA

If performance is poor:

Check if indexes exist on R_OBJECT_ID, AMS_RESPONSIBLEORGANISATION, I_IS_DELETED, and I_HAS_FOLDER.

Consider adding composite indexes if filters and joins often use the same columns.

Verify statistics are up to date (stale stats can lead to full table scans).

Compare actual vs. estimated rows in AUTOTRACE or DBMS_XPLAN.DISPLAY_CURSOR.

                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ TABLE ACCESS FULL           ‚îÇ
                ‚îÇ AMS_CASE_S                  ‚îÇ
                ‚îÇ Filter: Org_10              ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ TABLE ACCESS FULL           ‚îÇ
                ‚îÇ DM_SYSOBJECT_S              ‚îÇ
                ‚îÇ Filter: not deleted, has folder ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ HASH JOIN                   ‚îÇ
                ‚îÇ Join: C.R_OBJECT_ID = D.R_OBJECT_ID ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ INDEX UNIQUE SCAN           ‚îÇ
                ‚îÇ SYS_C008599 (on R_OBJECT_ID)‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ NESTED LOOPS                ‚îÇ
                ‚îÇ Combine hash join + index   ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ TABLE ACCESS FULL           ‚îÇ
                ‚îÇ AMS_CASE_R (large table)    ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ HASH JOIN (Final Join)      ‚îÇ
                ‚îÇ Join Nested Loop + AMS_CASE_R‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ SELECT STATEMENT (output)   ‚îÇ
                ‚îÇ ~4000 rows, cost 480        ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üß† Summary (What‚Äôs Happening)

Oracle scans two smaller tables (AMS_CASE_S, DM_SYSOBJECT_S), filtering them.

It hash joins them using R_OBJECT_ID.

Then it uses an index scan (SYS_C008599) to fetch related data efficiently.

The nested loop operation combines those results with the index lookups.

Finally, it hash joins that intermediate result with the large table AMS_CASE_R, completing the query.